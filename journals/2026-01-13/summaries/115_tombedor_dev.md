## MCPは一過性の流行に過ぎない

https://tombedor.dev/mcp-is-a-fad/

**Original Title**: MCP is a fad

MCP（Model Context Protocol）のアーキテクチャ的欠陥を鋭く指摘し、既存の技術スタックこそが持続可能なAI統合の鍵であると断じる。

**Content Type**: 🎭 AI Hype
**Language**: en

**Scores**: Signal:4/5 | Depth:4/5 | Unique:5/5 | Practical:4/5 | Anti-Hype:5/5
**Main Journal**: 91/100 | **Annex Potential**: 93/100 | **Overall**: 88/100

**Topics**: [[MCP, AI Agents, Tool Calling, Security, Software Architecture]]

著者は、現在AI統合の標準として急速に普及しているModel Context Protocol (MCP) を、実態を伴わない一過性の流行（ファド）に過ぎないと断じている。その人気の主な理由は、MCPが真に独自の課題を解決しているからではなく、Anthropicによる強力な後押しと、ツール作者にとっての容易なマーケティングチャネルとして機能したためだと分析している。

まず、MCPが解決を謳う「N×M問題（エージェントとツールの組み合わせ爆発）」について、著者は誇張であると指摘する。OpenAIやGeminiなど各社APIの形状の差異は軽微であり、LangChainやLiteLLMといった既存の抽象化レイヤーで十分に解決可能だ。その上で、MCPが採用する「ツール実行を別プロセスに分離するアーキテクチャ」が、環境変数の欠落、ゾンビプロセスの発生、メモリリーク、リソース競合といった運用上の深刻な問題を引き起こすと批判している。特に、プロセスの境界を越えるたびにオーバーヘッドが発生し、アプリケーション側からツールの挙動を制御・ロギングする能力が失われる点を問題視している。

実用面においても、MCPサーバーとしてツールをバラバラに提供する構造は、エージェントに「非一貫的なツールボックス」を強いることになる。ツール同士が互いの存在を認識できないため、プロンプトによる指示が重複・衝突し、結果としてトークンの浪費やエージェントの混乱を招く。さらにセキュリティ面では、認証のないサーバーの乱立や、プロンプトインジェクションを起点としたリモートコード実行（RCE）、データ漏洩のリスクが具体的なCVE（共通脆弱性識別子）とともに示されている。

著者は、MCPの代替案として「エージェントに直接ローカルスクリプト（justfileやMakefileなど）を実行させる」シンプルな手法や、既存のOpenAPI/RESTの活用を強く推奨している。エンジニアにとっての真の価値は、AIが容易に生成・保守できる小さなユーティリティスクリプトを、使い慣れたセキュリティ境界内で運用することにある。著者は、MCPのような過剰設計な規格は、モデルプロバイダーによるネイティブ機能の拡充や、実績のある既存の技術スタックによって、短期間のうちに淘汰されるだろうと予測している。