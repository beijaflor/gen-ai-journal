# GenAI週刊 2025年12月20日号

今週のAI・コーディング関連の重要な動向をお届けします。

## 今週のハイライト

2025年も師走に入り、AIコーディングツールの世界は大きな転換点を迎えています。今週の22の記事を通じて見えてくるのは、**ツールの進化から設計思想の成熟へ**という明確なシフトです。

まず目を引くのは、「仕様書駆動開発」という新しいパラダイムの台頭です。cc-sdd、OpenSpec、spec-kitといったツールが登場し、AIと協働するための「仕様ファースト」の開発手法が確立されつつあります。これはVibe Codingの限界を乗り越え、「考えてから作る」という本質に立ち返る動きと言えるでしょう。初心者が生成AIをどう活用すべきかという根本的な問いに対する、ベテランプログラマの実践的な回答がここにあります。

次に、MCPエコシステムの成熟が際立っています。AnthropicのMCPが登場してわずか数週間で、WorkOSのOAuth+CIMD統合による企業レベルのセキュリティ実装や、Web APIをMCP Gateway化する実践的なアーキテクチャが登場しました。これは単なるツールの追加ではなく、AIエージェントが信頼できるインフラとして企業システムに統合される未来の到来を意味します。

そして、PerplexityやNotebookLMのような成功例から学ぶ「インテリジェンス・フロー・アーキテクチャ」の重要性、ChatGPTのUI崩壊パターンから見えるUX設計の難しさ。これらの知見は、AIプロダクトにおけるUXデザイナーの役割が「オプション」ではなく「必須」であることを示しています。そして、デザイナーだけでなく、エンジニアも「仕様を考える人」へと役割が進化する中で、私たちの働き方の本質が問われています。

## 1. AIコーディングエージェントの本質的学び

### Claude Agent SDKでQ&Aエージェントを開発して得た学び

https://zenn.dev/loglass/articles/ab5431010454b0

ログラスのエンジニアがClaude Agent SDKを用いて社内Q&Aエージェントを開発し、AIの回答精度を高めるためのコード品質、ドキュメント整備、UX改善における実践的な知見を共有します。




ログラスのエンジニアが社内向けのプロダクト仕様Q&Aエージェントを開発する過程で得た学びを詳細に解説しています。このエージェントは、非エンジニアが仕様疑問を自己解決できるよう、ソースコードやドキュメントを読み込んで回答を提供するもので、単なる検索ツールを超えて運用相談にも活用されるほどの成果を上げました。

技術選定の中心はClaude Agent SDKで、著者は自前でのエージェントループやツール呼び出し制御の実装を省き、「何を読ませるか」「どう答えさせるか」のロジックに集中できた点を高く評価しています。複雑なRAGパイプラインやベクトルDBを構築せずとも、コードやドキュメントを読ませるシンプルなアプローチで実用的なエージェントが構築できたと報告されています。実装言語にはTypeScriptが選ばれ、UIは全社員が利用するSlack上で展開されました。

特に注目すべきは、AIの回答が遅延する問題へのUX改善策として、「問い合わせ中」ステータスの可視化とプログレス表示を導入した点です。これにより、ユーザーはエージェントが動作していることを把握し、体感的な待ち時間を削減できました。

運用を通じて得られた「AIに賢く答えてもらうための3つの学び」は、ウェブアプリケーションエンジニアにとって示唆に富んでいます。第一に、インプットの質が全てであり、ノイズの多い過去の問い合わせ履歴ではなく、ソースコード、リリースノート（変更意図や背景）、ユビキタス言語集といった信頼できる情報に厳選すべきだと強調されています。第二に、「隠れたロジック」（例：SQLのWHERE句に埋め込まれたルール）はAIにとって見えにくく、ドメインロジックをコードとして明示的に表現することの重要性が再認識されました。これは、人間にとっても読みやすいコードがAIにとっても読みやすいという原則に繋がります。第三に、コードコメントはAIにとって「検索アンカー」として機能し、的確なコメントが関連コードのヒット率を高めると指摘されています。

さらに、GitHub APIのレートリミットという課題に直面した際、GitHub MCPサーバー経由でのコード取得から、エージェントが動作するサーバーに直接リポジトリを`git pull`してローカルファイルとして読ませるという、一見泥臭い方法に切り替えたことで、レートリミットの撤廃と劇的な速度向上が実現した運用上の工夫も紹介されています。

本記事の最大の学びは、「AIに正しく仕様を理解させるには、人間にとっても読みやすいコードとドキュメントが必要」という、本質的なソフトウェア開発の「良い習慣」の再確認にあります。AIのために整備された情報は、結果として新メンバーや非エンジニアにとっても有益な資産となる、と著者は締めくくっています。

---

### AI駆動開発を意識したドキュメント運用について考えてみる

https://tech.every.tv/entry/2025/12/13/120000

AI駆動開発の文脈でドキュメント運用のあり方を考察し、エブリー社のトモニテ開発部での具体的な方針を提示します。




エブリーテックブログは、AI駆動開発におけるドキュメント運用について、その重要性と具体的なアプローチを考察しています。最近のAI技術の急速な発展により、ドキュメントの作成や運用も大きく変化しており、特にAIに与える「コンテキスト」の質がAIの出力精度に決定的な影響を与えると指摘。そのため、内部の人間しか知り得ないプロジェクト固有の知識をいかに効率的かつ正確にドキュメント化し、AIに利用させるかが重要な課題であると筆者は述べています。

記事では、AI駆動開発を意識したドキュメント運用を考える上での4つの観点――「何をドキュメンテーションするか」「どこにドキュメントを保存するか」「どのようにドキュメントを更新するか」「どのようにAIに利用させるか」を詳細に掘り下げています。例えば、「何を」では読者（エンジニア、他職種、あるいはAI）やドキュメントの目的（要件定義、仕様、設計など）を明確にすることが肝要だと説きます。「どこに」ではGitHub、Notion、Confluenceといった保存場所の選択肢と、AIの参照しやすさ、人のアクセシビリティを考慮した構成の重要性を示唆。「どのように更新」では手動更新に加え、CIによる自動生成やAI自身による修正といった新しいアプローチに触れ、ドキュメントの「鮮度」維持がAI駆動開発におけるコンテキストの質を保つ上で極めて重要であると強調します。「どのようにAIに利用させるか」については、CursorのようなAIエディタやModel Context Protocol (MCP) を活用した参照方法、さらにはAGENTS.mdのようなルールファイルにドキュメントへの導線を記述し、AIが適切なタイミングで情報を取得できるよう促す方法を提案しています。なお、2025年12月10日時点でのCursorのGitHub MCPにおけるファイル参照の課題にも言及しています。

筆者が所属するトモニテ開発部では、これらの観点を踏まえ、以下の運用方針を構想し実践しています。まず、ドキュメントをGitHubリポジトリにMarkdown形式で集約し、エンジニアだけでなくPMも容易に利用できる体制を構築。Mermaid記法で図もテキストベースで管理することで、AIによる解釈や修正を容易にしています。また、ドキュメントリポジトリを「トモニテのドキュメントマスタ」として、サービス全体の構成や施策の背景・仕様といった広範な情報を集約。各領域に特化した知識は個別のリポジトリに配置し、全体像と詳細情報の両方へアクセスしやすい構造を目指しています。運用は始まったばかりですが、既にAIの実装精度向上や、プルリクエストを参照したドキュメントの自動更新といった効果を実感していると報告しています。AIを意識したドキュメント運用は試行錯誤の段階にあるとしつつも、人間だけでなくAIが主要な読者となりうる未来において、ドキュメントの保存場所や記述方法の最適解が変化していく可能性を示唆し、今後の継続的な改善の重要性を締めくくっています。

---

### なぜあなたのVibeコードプロジェクトには開発者が必要なのか

https://evilmartians.com/chronicles/why-your-vibe-coded-project-needs-a-developer

Vibeコーディングは迅速なプロトタイプ作成に優れているものの、持続可能で高品質なプロダクトには経験豊富な開発者によるコードの整理と適切なアーキテクチャ設計が不可欠であると著者は主張する。




本記事は、AIがコードを生成する「Vibeコーディング」がプロトタイプ作成やアイデア検証には効果的であるものの、プロトタイプと本番環境対応のプロダクトとの間には大きな隔たりがあると指摘している。著者は、数多くのVibeコードプロジェクトを見てきた経験から、AIが生成するコードはオンラインで利用可能なコードの統計的平均から学習するため、必ずしも最適なパターンではなく「デフォルトで平凡」なものになると説明する。

記事は、Vibeコードプロジェクトで頻繁に発生する共通の問題点を以下のように挙げている。
*   **不明確なドメインモデル**: ビジネスロジックがReactコンポーネント全体に分散し、システムの振る舞いが体系的に定義されていない。
*   **集中型コンポーネント**: ロジック、APIリクエスト、UIに関する懸念事項が少数の「ゴッドコンポーネント」に集約され、変更が予期せぬ破壊につながるリスクがある。
*   **再利用の欠如**: 同じロジックが異なる箇所にコピー＆ペーストされ、一箇所でのバグ修正が他の複数箇所での修正漏れを引き起こす。
*   **TypeScriptのキャスト乱用**: 型エラーが未熟な開発者のように安易なキャストで解決され、TypeScriptが提供するドキュメンテーション、安全性、リファクタリング時の信頼性が失われる。
*   **セキュリティの軽視**: 入力検証の不足や機密データの不適切なロギングなど、デモ段階では問題にならないが本番環境で深刻な脆弱性となる問題が潜んでいる。
*   **技術的負債の蓄積**: これら全ての安易な決定が積み重なり、最終的に新機能の追加や安全なリファクタリングが遅く、高コストになる。

著者は、Evil Martiansのチーム内でデザイナーがVibeコーディングで作成したアクセシブルなカラーパレット生成ツール「Harmonizer」の事例を紹介している。このツールはアイデア検証には成功したが、実用化の段階でパフォーマンス問題（例えば、パレットの再計算に200ミリ秒かかる、ホバーごとにグリッド全体が不要に再レンダリングされる）が浮上した。これは、全てのロジックがReactコンポーネント内にあり、UIとビジネスロジックが分離されていなかったためである。

経験豊富な開発者である著者は、この問題を解決するためにロジックをシグナルベースのストアに抽出し、重い色計算をWeb Workerにオフロードし、全ての構造を複数のプラットフォームに対応できるコアパッケージに再構築した。その結果、60fpsの描画性能を実現し、不要な再レンダリングをなくし、Figmaプラグイン版の開発も容易な拡張性の高いアーキテクチャを構築できた。

この事例を通して著者は、Vibeコーディングはアイデア検証には非常に価値があるものの、持続可能で高品質なプロダクトを構築するには、経験豊富な開発者がコードの整理、アーキテクチャの再構築、適切な技術的判断を行うことが不可欠であると結論付けている。著者は、むしろプロジェクトの初期段階から経験豊富な開発者を関与させることで、AIが生成したコードの問題が深刻化する前に特定し、適切な指導を行うことができると提言している。Vibeコーディングは検証を行い、開発者がそれを永続的なものにするという点が本稿の重要なメッセージである。

---

### ベテランプログラマは生成AIをどう活用しているのか？そして初学者は生成AIをどう活用すべきか？

https://blog.jnito.com/entry/2025/12/15/073604

ベテランプログラマが生成AIの具体的な活用術と、初学者が陥りやすい落とし穴を指摘しつつ、AIを効果的に使いこなすためのマイルールを提示する。




ベテランプログラマの伊藤淳一氏が、自身のClaude CodeやChatGPTの活用経験に基づき、生成AIの具体的な利用シーンと、効率的に使いこなすためのマイルールを解説する。氏がAIを活用するのは、面倒な定型コードの生成、調査時間の短縮、実装方針の叩き台作成、巨大コードベースの調査、曖昧な情報の質問、長いissue/PRの要約といった、AIを使わない場合でも自力で解決可能だが、AIによって時間や労力を削減できる領域だ。

AIを効果的に活用するマイルールとして、伊藤氏は10点を挙げる。初期導入時は経験者を頼り、いきなりコードを書かせずにPlan Modeで計画を確認すること。タスクを細かく分解して人間が指示し、間違いに備えてこまめにコミットする。AIを人間だと思い必要な情報をすべて与え、生成AIのコードにも自分が責任を持つ。AIより自分で書く方が速い場合はそちらを選び、AIの出力で不明な点は放置せず調べる。AIの情報を鵜呑みにせず裏を取り、生成AIブームに流されずマイペースで付き合うことを強調する。

特にプログラミング初学者に対しては、「自分のスキルとイコールか1段上」のタスクにAIの利用を限定するよう強く提言する。自身の税理士関連の経験から、「生成AIに上手に説明できない」「AIのアウトプットを適切に評価できない」状況では、AIは誤った結果を招くことを具体例で示す。初学者が自身のスキルを飛び越える課題にAIを使っても、結局行き詰まるか誤った知識を身につけるリスクがあるためだ。生成AIはあくまでツールであり、それを使いこなすためには地道な専門知識の習得が不可欠であり、プログラマの本質的な仕事がなくなることはないと結論付ける。

---

### 思考する暇もない：AIバイブコーディングの隠れた疲労

https://www.tabulamag.com/p/too-fast-to-think-the-hidden-fatigue

AIによる高速な「バイブコーディング」は開発を加速する一方で、思考を追いつかなくさせ、新たな疲労と精神的課題を引き起こすと著者は主張します。




ベテラン開発者である著者のステファン・シュミット氏は、Claude CodeとCursorを用いた「バイブコーディング」が開発速度を劇的に向上させた一方で、これまで経験したことのない「疲労」を感じていると述べています。これは、AIが驚異的な速度でコード生成やバグ修正、テスト作成をこなすため、人間の脳がその情報処理速度に追いつけず、認知負荷が過大になることが原因だと分析しています。

従来のコーディングでは、アウトプットの速度はタスクの複雑さや自身の思考速度と一致し、脳が情報を処理する十分な時間がありました。しかし、AIとのバイブコーディングでは、思考が詰まり、アーキテクチャや意思決定、エッジケースを「寝かせる」時間がなく、AIの生成物を一貫した全体像として捉えることが困難になります。著者はこれを「スプリントのペースでマラソンを走るようなもの」と表現しています。

また、コードが動くたびに得られるドーパミン報酬ループの加速は、脳を圧倒し、通常のコーディングの満足感ではなく疲労とストレスホルモンをもたらす可能性があります。AIによって、脳のキャッシュをクリアして新しいコンテキストをロードするような「コンテキストスイッチ」の頻度が激増し、これが脳に大きなエネルギー消費を強いることで疲労に繋がると指摘しています。開発者の役割がコードを書くことからAIの出力を管理・レビューすることへと変化し、まるで複数の交差点を同時に監視する交通整理官のように、より深いレベルでの管理責任がストレスを増幅させると著者は警鐘を鳴らしています。

この問題に対処するため、著者は以下の点を提言しています。
*   AIツール使用時の意図的なペース調整。
*   AI導入による影響を理解するための、AIを意識したレトロスペクティブ（日次の実施も含む）。
*   AIコーダーの新たな精神的健康課題への認識。
*   AIのマイクロマネジメントを減らし、よりAIを信頼すること。

AIが開発速度を格段に向上させた一方で、人間の脳がそのペースに適応しきれていない現状を認識し、新たなリズムや境界線、そして「コーディングする」ことの意味を再考する必要がある、と結論付けています。未来のコーディングは、意図的に「遅く」することも求められるかもしれません。

---

## 2. 仕様駆動開発とツール

### 1行もコードを書かずにGeminiだけでUnityの大富豪ゲームを作って公開した話

https://zenn.dev/tomotomobile/articles/b5cf31891b77e2

著者は、GeminiとGeminiCLIのみを使い、自身は一切コードを書かずにUnityで大富豪ゲームを開発し、その過程で得られた知見と課題を共有します。




記事は、フリーランスのPdMである著者が「自身は1行もコードを書かない」という縛りで、GeminiとGeminiCLIを使ってUnityでCPU対戦型の大富豪ゲームを開発し公開した事例を紹介しています。開発は「PM兼テスター」に徹し、実装は全てAIエンジニアに任せるスタイルです。

開発のログは「カオスと再生の1週間」と題され、時系列でAIとのインタラクションが詳細に語られます。初期段階では、わずか2時間のプロンプトでゲームのコアロジック（カード配布、役判定、特殊ルール）が動作することに驚きを示しますが、UnityのUIレイアウトの調整が最大の課題となります。テキストベースの指示ではUIの複雑な崩れをAIに認識させ、修正させるのは困難であり、スクリーンショットをAIに投げかける「マルチモーダル・デバッグ」も期待通りの精度には至りませんでした。

AIによる繰り返しの修正がコードをスパゲッティ状態にし、最終的には「全消しリビルド」という大胆な決断に至ります。この際、著者は現在のゲーム仕様を「コード」ではなく「日本語の仕様書」としてGeminiCLIに作成させ、その仕様書を元にゼロからクリーンなコードを再生成させることに成功しました。この「仕様書駆動」のアプローチにより、リビルド後は開発が驚くほどスムーズに進み、GitHub Actionsによる自動デプロイを経てゲームが一般公開されました。

Geminiだけで開発して得られた知見として、著者は以下の3点を挙げています。
1.  **「コード」より「日本語の仕様書」を書け**: コードが複雑になった場合、プログラマーはリファクタリングをしますが、非エンジニアは正確な仕様ドキュメントを作成し、AIにクリーンなコードを再生成させる「仕様書駆動」がバイブコーディングの正解だと強調しています。
2.  **UI調整とマルチモーダルの壁（今後の課題）**: ロジック生成は優れているものの、UI調整はテキスト指示では限界があり、視覚情報をAIに正しくフィードバックして修正させる方法が今後の大きな課題であると指摘しています。
3.  **諦めて寝る、あるいは捨てる勇気**: AIがループに陥ったり、コードが収拾がつかなくなったりした場合は、チャットのリセットやコードの全捨て、そして仕様書からの再生成が結果的に早いとアドバイスしています。

まとめとして、UnityやC#の知識がない人間でも「PMとして仕様を定義し、QAとしてバグを報告する」だけで複雑なゲームを開発できたと結び、AIにコードを書かせる上で重要なのは「何をどう作りたいか」を言語化する力と、構造を見直す決断力であったと述べています。この記事自体も、GitログをGeminiに渡し、構成と執筆をAIに担当させた上で、著者がディレクションと細部の修正を行うという「PMと実務者」の役割分担を貫いた制作物であることも明かされています。

---

### Claude Codeで仕様書駆動開発！3つのツール比較（OpenSpec / spec-kit / cc-sdd）

https://zenn.dev/gmomedia/articles/8ccf71e50858de

Claude Codeを用いた仕様書駆動開発を実現する3つのツール（OpenSpec、spec-kit、cc-sdd）を比較し、それぞれの特徴と最適なユースケースを解説する。




本記事は、コードを書く前にAIと人間が「何を作るか」を合意する「仕様書駆動開発（Spec-Driven Development）」の重要性を論じている。著者は、このアプローチが「認識のずれの防止」「AIエージェントのセッション引き継ぎの容易さ」「人間の進捗把握」という3つのメリットをもたらすと説明している。その上で、Claude Codeと連携し仕様書駆動開発を支援する3つの主要ツール「OpenSpec」「spec-kit」「cc-sdd」を詳細に比較している。

「OpenSpec」はFission-AIが開発し、ファイル数が最小限でシンプルである点が特徴である。著者は、特に実装完了した変更を自動的にアーカイブする`/openspec:archive`コマンドをその最大の強みとして挙げ、これにより進行中と完了済みのタスクがディレクトリ構造から一目瞭然となり、既存サービスの改修作業に最適だと評価している。

「spec-kit」はGitHub公式が開発しており、`constitution.md`でプロジェクト原則を定義し、開発の全フェーズでその遵守を徹底できる設計が強みとされている。また、`tasks.md`内の`[P]`マーカーにより並列実行可能なタスクが明示され、中規模以上の開発チームでの分担や新規開発における堅牢な開発に適していると著者は指摘する。しかし、生成されるファイルが多く認知負荷が高い点や、日本語指定にもかかわらず英語ドキュメントが出力されることがある点が課題として挙げられている。

「cc-sdd」はgotalab製で、12言語対応が最大の特色である。特に`--lang ja`オプションで確実に日本語ドキュメントを生成できるため、多言語環境や日本語での仕様書管理を重視する開発者に有効だと著者は述べている。EARS形式の要件定義、Mermaid図を含む設計書生成、依存関係追跡付きタスク管理、npxでの容易な導入も特徴として挙げられている。

記事は最終的に、既存サービスの改修にはシンプルでアーカイブ機能を持つ「OpenSpec」、ゼロからの新規開発で堅牢なチーム開発を目指すなら「constitution」による原則遵守が可能な「spec-kit」、そして日本語でのドキュメント管理を重視するなら「cc-sdd」という使い分けの指針を提示している。著者の個人的な見解では、初めての仕様書駆動開発にはOpenSpec、ゼロから新規開発ならcc-sdd、チームでの新規開発ならspec-kitが推奨されている。

---

### GitHub Copilot の回答精度が大きく変わる。「.instructions.md」の書き方

https://zenn.dev/cscloud_blog/articles/0d27a926eff4cc

VSCodeのGitHub Copilot Chatにおいて、リポジトリのコンテキストとAIの振る舞いを定義する`.instructions.md`と`.agent.md`ファイルを活用することで、回答精度と開発効率を劇的に向上させます。




本記事は、GitHub Copilot Chatの回答精度を大幅に向上させるための`.instructions.md`と`.agent.md`ファイルの具体的な活用法を、VSCodeでの設定手順を交えながら解説しています。

著者は、`.instructions.md`がリポジトリ全体の目的、歴史的経緯、特徴的な設計、各ファイルやディレクトリのロジックなどをAIに伝える設定ファイルであると説明しています。これにより、開発者はAIに対し毎回プロジェクトの背景を説明する手間が省け、AIがベストプラクティスに固執してくることによる手戻りを減らし、調査や実装時間の短縮に繋がると強調しています。特に`applyTo`プロパティを使って適用範囲を細かく指定することで、不要なコンテキストの浪費を防ぎ、回答精度を高めることができる点が重要です。

また、`.agent.md`はAIに「プロのエンジニア」「常に日本語で応答する」といった役割や会話スタイルを定義するファイルとして紹介されています。これにより、開発者は毎回長文のペルソナ設定を行う必要がなくなり、応答の一貫性が保たれるとともに、エージェントごとに使用するAIモデルを決定できるため、プレミアムリクエストの無駄な消費も抑えられます。

これらの設定ファイルを整備することで、人間とAI双方にとってリポジトリのドキュメントとして機能し、コードの一貫性維持、オンボーディングの効率化、そして開発効率の劇的な改善が期待できると著者は指摘します。多くの開発者がまだこれらの機能を知らない現状を鑑み、本記事がより多くのリポジトリでの普及と運用ノウハウの蓄積に貢献することを願っています。

---

### AI設計壁打ちに使える、小さな合意を積み重ねるプロトコルを作った

https://zenn.dev/erukiti/articles/2512-micro-commit-protocol

AIエージェントとの設計プロセスで生じるユーザーの混乱を防ぎ、システムの全容を完全に理解しながら構築するために、最小単位で合意を積み重ねる「マイクロコミット合意プロトコル」を開発・公開しました。




AIエージェント、特に高性能なLLMとの設計作業において、ユーザーが大量の情報に圧倒され、AIが参照資料を絶対視して勝手に設計を進めてしまうことで、混乱やコンテキストの無駄な消費が発生するという課題が指摘されています。この課題を解決するため、著者は「マイクロコミット合意プロトコル」を開発しました。

このプロトコルは、ユーザーがシステムの全容を「完全に理解しながら」構築できるよう、すべての実装プロセスを最小単位で可視化・直列化し、その時々の情報量を最小限に抑えることを目的としています。

プロトコルは以下の3つのルールで構成されています。
1.  **完全網羅と不可視化の禁止 (No Skipping)**: 複雑な論点だけでなく、「自明な実装」や「定数定義」などの単純作業も決してスキップせず、すべての工程を最小の構成要素に分解し、必ず一つずつ提示します。「その他はよしなにやっておきました」は厳禁とし、ファイルパスやDB名・カラム名を具体的に記述。既存コードと今回の意思決定が矛盾する場合は、意思決定を正として既存コードを破棄・置換することを重視します。
2.  **ナビゲーションと提示 (One by One)**: 依存関係の最も低い基礎から順に、AIが次のステップを選定し、提示します。各ステップでは、特定のフォーマット（「Step #n: 今回積み上げるパーツ」「合意対象内容」「解説」）のみを出力し、停止します。合意対象内容は3項目以内の具体的な仕様案とし、ユーザーの判断が必須な場合のみ選択肢や質問を記述します。
3.  **承認と進行 (Wait for Understanding)**: AIは提示後、必ず停止し、ユーザーの「OK」を待ってそのパーツの実装が完了したとみなし、即座に次のステップへ進みます。ユーザーが質問や修正を求めたら、それに応じ、合意した内容は設計書と意思決定ログに記載します。

著者は、このプロトコルをCodex with gpt-5.2で試したところ、やり取りの回数は増えるものの、大量の情報を投げ込まれて抜け漏れが発生したり、AIが謎の思い込みで作業したりすることを防ぎ、効率的な設計壁打ちが可能になったと述べています。これは「急がば回れ」のアプローチとして有効であるとしています。ただし、GeminiやClaudeなど他のLLMでの動作は未検証であり、微調整が必要な可能性を指摘。また、数十個のマイクロコミットの意思決定をまとめる難しさや、一回の合意項目を3つに絞るのが進捗を遅らせるため、5つにするか動的に調整するなどのさらなる工夫が必要であることも追記しています。

---

### レビューしやすい設計書を作ってくれるエージェント決定戦！ cc-sddで設計書作って比べてみた #ClaudeCode

https://qiita.com/kaaaichi_i/items/7083543acaad53c39b30

仕様駆動開発における設計書レビューの負荷軽減を目指し、cc-sddライブラリを用いてClaude Code、Codex CLI、Gemini CLIの3つのAIコーディングエージェントが生成する設計書の質と特徴を比較・評価した。




本記事は、仕様駆動開発（SDD）における設計書レビューの負担に着目し、OSSライブラリ「cc-sdd」を活用して主要AIコーディングエージェントの出力品質を比較検証した。個人開発の「思い出アルバムアプリ」に「最新の思い出」機能を追加するという架空のシナリオを設定し、GitHub Issueから要件定義書（requirements.md）と技術設計書（design.md）を各エージェントに生成させ、その結果を詳細に比較している。

比較観点としては、生成される文字数、文章の長さ、文章構造、そして理解を助ける要素（図や箇条書きなど）に焦点を当てている。

各エージェントの主な特徴は以下の通りである。
- **Claude Code**: cc-sddテンプレートに忠実で、英単語と日本語が混ざるものの、型に沿った解釈しやすい文章を生成する。シーケンス図や箇条書きが適切で、既存アーキテクチャ分析や実装戦略まで考慮された堅実な設計を行う。設計書作成はスムーズに進んだ。
- **Gemini CLI**: 生成される文字数は少なめから中程度。英文と日本語が混ざり、形式化されていない文章が生成されることもあるため、好みが分かれる可能性がある。mermaid図は適切に使用するが、design.mdがシンプルすぎる傾向があった。
- **Codex CLI**: 生成される文字数は多め。自然な日本語で読みやすいドキュメントを生成しようとするが、文章の型は決まっていない。mermaid図は適切に作成するが、初期段階でシーケンス図は生成されなかった。具体的な実装に関する記載が深く、実装時の手戻りを減らせる可能性が高いが、一部意図せぬ動作も見られた。

著者は、全体的な「読みやすさ」という観点では自然な日本語で出力されるCodex CLIを推奨しつつも、文章の型が決まっているため慣れれば解釈しやすいClaude Codeが好みだと述べている。この比較により、同じcc-sddのプロンプトを使用しても、エージェントのモデル特性によって設計書の出力に大きな違いが生じることが明らかになった。最終的な設計書の精度ではCodex CLIとClaude Codeが高評価で、不足部分は人間のレビューと修正が前提となるcc-sddの利用において問題ないとしている。この検証は、AIエージェントの選定や、それぞれの特性を理解した上での効果的な活用方法を検討するウェブアプリケーションエンジニアにとって、具体的な指針を提供するものとなる。

---

## 3. MCPとAIエージェントインフラ

### AIエージェント向けMCP認証：CIMDを用いたPython OAuthクライアントの登録方法

https://workos.com/blog/mcp-auth-for-ai-agents-how-to-register-a-python-oauth-client-using-cimd

本記事は、AIエージェントがMCPサーバーに接続する際のOAuthクライアント登録を、Client ID Metadata Documents (CIMD) を用いてPythonでセキュアかつスケーラブルに実装する方法を詳細に解説しています。




AIエージェントがMCPサーバーのツールと安全に連携するためには、OAuthトークンを信頼できる形で取得する必要があります。本記事は、この課題を解決する手段として、MCP 2025-11-25の仕様更新で推奨されるClient ID Metadata Documents（CIMD）を用いたPython OAuthクライアントの実装方法を、網羅的なチュートリアル形式で紹介しています。

従来のサーバーごとのクライアント登録やシークレットの管理が抱える脆弱性やスケーラビリティの問題に対し、CIMDはクライアント自身がHTTPS URLとしてクライアントIDを提供し、そのURLから自身のメタデータ（リダイレクトURI、認証方式、公開鍵の場所など）をJSONドキュメントとして公開するという「キーを自分で持ち込む（bring your own keys）」モデルを提案しています。これにより、クライアントは安定した単一のIDとキーペアで複数のMCPサーバーに対応でき、シークレットの散乱（secret sprawl）を防ぐことができます。これは、ウェブアプリケーションエンジニアがAIエージェントを大規模に展開する際に特に重要な利点です。

記事では、CIMDをPythonでエンドツーエンドに実装する手順を具体的に示しています。主な内容は以下の通りです。
1.  **CIMDドキュメントとJWKSエンドポイントのホスティング**: クライアントが自身の公開鍵を含むJWKS（JSON Web Key Set）と、クライアントのメタデータを定義するCIMDドキュメントをHTTPSで公開する方法。これはクライアントIDとして機能し、認証サーバーが動的にクライアント情報を取得するために利用されます。
2.  **OAuthフローの開始とPKCEの利用**: 認証コードフローを開始し、セキュリティ強化のためにPKCE（Proof Key for Code Exchange）パラメーター（`code_challenge`, `code_challenge_method`）を含めて認証サーバーにリダイレクトする方法。
3.  **認証サーバーによるCIMDの検証**: 認証サーバーがクライアントID URLからCIMDドキュメントをフェッチし、その内容（`client_id`とURLの一致、`redirect_uris`の厳密な照合など）を検証するプロセス。
4.  **クライアントアサーションJWTの構築と署名**: 認証コードをトークンに交換する際に、`private_key_jwt`認証方式を用いるため、クライアントの秘密鍵で署名されたクライアントアサーションJWTを生成する方法。これにより、共有シークレットなしでクライアントの身元を証明します。
5.  **トークン交換とMCPサーバーでのアクセストークン検証**: 認証コード、PKCE検証者、クライアントアサーションJWTを用いてトークンエンドポイントでアクセストークンを取得し、最後にMCPサーバーがそのトークンを検証する詳細なステップ。

Pythonの`cryptography`、`PyJWT`、`requests`といったライブラリを用いた具体的なコード例が豊富に提供されており、ウェブアプリケーションエンジニアがAIエージェントの認証機能を実装する上で即座に役立つ内容となっています。特に、URLの厳密な一致、キーローテーションの考慮、不一致エラー発生時のトラブルシューティングヒントなど、実運用における重要な注意点も挙げられており、セキュアで堅牢なAIエージェントの構築を目指す開発者にとって必読のガイドです。

---

### Web APIをMCP化してAgent-readyにした話

https://developers.cyberagent.co.jp/blog/archives/60687/

サイバーエージェントのAI事業本部は、既存のOpenAPI準拠Web API群をAIエージェントから容易に利用可能な「Agent-ready」状態にするため、FastMCPフレームワークを活用してMCP Gatewayを構築しました。




サイバーエージェントのAI事業本部は、レスポンシブ検索広告の品質向上を目指し、広告文の品質判定APIなど複数のWeb APIをAIエージェントから連携可能にする「Agent-ready」化に取り組みました。既存のAPIをAIエージェントが直接呼び出す場合、各エージェントでの個別ロジック実装やAPI仕様変更時のメンテナンスコストが課題となるため、MCP（Model Context Protocol）サーバーの導入が決定されました。

チームは、個別のAPIごとにMCPサーバーを開発するのではなく、複数のAPIサーバーの前段にGatewayの役割を持つMCPサーバー（MCP Gateway）を配置するパターンを選択しました。この決定は、MCPサーバーの開発・運用コストを抑えたいという動機と、通信オーバーヘッドがユースケースにおいて許容範囲内であったためです。

MCP Gatewayの構築には、Python向けのフレームワークであるFastMCPが活用されました。具体的には、OpenAPI準拠の既存APIからMCPサーバーを自動生成する「OpenAPI統合機能」と、複数のMCPサーバーを一つにまとめる「Server Composition機能」の`mount`方式を組み合わせることで実現されました。このアプローチにより、手動でのMCPツールやリソース構築の手間が省け、既存のWeb APIを迅速にMCP化し、AIエージェントから一元的に利用できるようになります。

このGatewayをClaude CodeなどのAIエージェントに登録するだけで、複数のWeb APIが利用可能となり、広告文の生成と品質判定のイテレーションを効率的に回し、広告効果の最大化が期待されます。一方で、OpenAPI Specから自動生成されるMCPツール・リソースがエンドポイント単位であるため、エンドポイント数が非常に多い場合にはLLMのコンテキストを圧迫する可能性が注意点として挙げられています。著者は、Anthropic社のtool searchのような新技術が、将来的にこの課題を解決する可能性を示唆しています。

---

### AIエージェント/MCPサーバー実装ガイドを作成しました

https://tech-lab.sios.jp/archives/50769

サイオステクノロジーは、AIエージェントとMCPサーバーの実装を体系的に学べる201ページの詳細ガイドを公開しました。




サイオステクノロジーは、AIをより便利に活用するためのAIエージェントとその拡張技術であるMCP（Model Context Protocol）サーバーの実装を体系的に学べる「AIエージェント/MCPサーバー実装ガイド」を公開しました。このガイドは、201ページに及ぶ大ボリュームの教科書として、AIエージェントとMCPの基本的な概念から実践的な実装までを網羅しています。

本ガイドは、これからAIエージェントやMCPを学ぶ開発者だけでなく、AIエージェント/MCP開発プロジェクトのプロジェクトリーダーやプロジェクトマネージャーも対象としています。実装の方法やソースコードだけでなく、AIエージェント/MCPサーバーの基礎理論も図解たっぷりで説明されており、技術選定やアーキテクチャ設計に必要な全体像と思考法を提供します。これにより、実装の詳細に踏み込む前段階として全体像や考え方を把握したい方や、初めてAIエージェントやMCPに触れる方が「なぜこの仕組みが必要なのか」「どのような役割分担で構成されているのか」といった背景を理解し、開発チームとマネジメント層の共通言語を築く資料としても機能します。筆者は、単なる実装手順書ではなく、AIエージェント/MCPをプロジェクトとして成功させるための土台となる知識を体系的に整理したガイドであると強調しています。

ガイドの主な特徴は三つです。第一に、複雑な概念も直感的に理解できるよう、豊富な図や画面ショットを多用しています。第二に、AIエージェントやMCPの仕組みを基礎の基礎から解説しており、単なるツールの操作説明にとどまらず、その活用方法まで深く掘り下げています。第三に、理論だけでなく、すぐに動作確認できるソースコードを公開し、詳細な説明も付記しているため、実践的な学習が可能です。

具体的には、ReActによるAIエージェントの基本動作、Function Callingを用いた実用的な実装、MCPの理論とプロトコル構造、シンプルなMCPサーバーの構築、エンタープライズ向けに必須となる認可機能、そしてMCP対応AIエージェントの本格的な実装方法まで、7章構成で詳細に解説されています。ガイドは解説セミナーを通じてダウンロードURLが公開されます。

---

### なぜ今、Agentic Workflowなのか - Graflowの設計思想

https://zenn.dev/myui/articles/64f31faaf1488c

Graflowは、AIエージェントのプロダクション環境における「理想と現実のギャップ」を解消するため、ワークフローオーケストレーションに特化した、柔軟性と制御性を両立する新しいエンジンを提供します。




本記事は、AIエージェントをプロダクション環境で運用する際の課題、特に「自律性と制御性の両立」に着目し、著者が開発する新しいオーケストレーションエンジン「Graflow」の設計思想を解説しています。現在のAIエージェントフレームワークが「SuperAgent型」に傾倒し、エージェント内部の推論ループまでグラフ化するLangGraphのようなアプローチが可読性や保守性の課題を抱える中、Graflowは異なる戦略を打ち出します。

Graflowは、AIワークフローを「Type B: Agentic Workflow（構造化フロー + エージェント自律性）」に特化することで、「制御された自律性」を実現することを目指しています。これは、ワークフロー全体は人間が設計しつつ、各タスク内部でエージェントが自律的に動作するというアプローチです。既存のSuperAgent型フレームワーク（Google ADK、PydanticAIなど）は「Fatノード」としてラップし、ワークフローオーケストレーションに集中することで、各領域のベストツールを活用できる「責務分離型」の利点を強調しています。

Graflowが解決する具体的な実務課題は多岐にわたります。LangGraphが抱える課題として、エージェント内部の推論ループまでグラフ化することによる可読性・保守性の低下に対し、GraflowはSuperAgentをFatノードとして扱い、ワークフローの「タスク間の連携」に注力します。また、LangGraphで事前定義が必要な条件分岐やループの柔軟性の低さに対しては、実行時の動的なタスク生成や条件分岐を可能にする`context.next_task()`や`context.next_iteration()`を提供。長時間ワークフローの途中落ち問題には、ユーザー制御の`checkpoint/resume`で再開を可能にし、承認待ちのHuman-in-the-Loop（HITL）も`checkpoint`と組み合わせることで効率化します。さらに、タスクの並列処理とワーカーの水平スケールを実現するため、Redisベースの分散実行アーキテクチャを採用し、シンプルなAPIで切り替えを可能にしています。

その他の重要機能として、軽量なLLM呼び出しを可能にする`inject_llm_client`、DAGとState Machineのハイブリッド設計をPythonic演算子DSLで記述できる柔軟性、Docker実行を標準装備したプラグ可能タスクハンドラー、タスク間のステート共有を担うChannel通信（型安全なTypedChannelを含む）、並列タスク実行時の細粒度エラーポリシー（Strict/Best-effort/At-least-N/Critical Tasks）、そしてLangFuse/OpenTelemetryを統合した実行時の可観測性強化（自動トレース収集とOpenTelemetryコンテキスト伝播）が挙げられます。

Graflowは2026年1月にOSS公開を予定しており、生産環境でAIエージェントワークフローを安心して動かすための、戦略的シンプルさ、実行時の柔軟性、開発体験、プロダクション対応、並列分散処理によるスケーリングをコア価値としています。

---

## 4. プロダクト設計とUX

### PerplexityとNotebookLMが「より良いAI」ではなく「より良いインテリジェンス・フロー・アーキテクチャ」を利用している理由

https://uxdesign.cc/perplexity-and-notebooklm-dont-use-better-ai-they-use-better-intelligence-flow-architecture-ace59eeda531

PerplexityやNotebookLMの成功は、単に優れたAIモデルに起因するのではなく、人間とAI間の認知的作業の流れを革新的に設計する「インテリジェンス・フロー・アーキテクチャ」によってもたらされると筆者は主張する。




AIプロダクトの成功要因について、本記事はPerplexityやNotebookLMが際立つのは、単なるAIモデルの優劣ではなく、「インテリジェンス・フロー・アーキテクチャ」（Intelligence Flow Architecture: IFA）という、人間とAIの協調作業の流れを設計する新しいアプローチにあると指摘する。これは、認知的作業が人間とAIの間でどのように分担され、シームレスに連携するかを構造的に設計する分野だ。

Webアプリケーションエンジニアにとって、これはAI機能を既存UIに「アドオンする」従来の手法から、インテリジェンスをシステムの核として「組み込む」設計思想への根本的転換を促す。OpenAIの共同創設者Andrej Karpathy氏が「LLMはOSであり、真のデザインは問題解決のオーケストレーション」と述べたように、AIを最大限に活かすには協調の構造設計が鍵となる。

記事は、PerplexityとNotebookLMのアーキテクチャを分析し、両者が以下の4つの原則を共有していることを示す。

1.  **自律的な実行からの逆算設計**: UIからではなく、AIが自律的に「何をするか」（検索、合成、分析など）から設計を始める。これにより、インテリジェンスは後付け機能でなく、システムの価値を定義する実行レイヤーとして機能する。
2.  **特定のレイヤーへのインテリジェンス埋め込み**: AIは単なる機能追加でなく、Perplexityの合成レイヤーやNotebookLMの知識処理レイヤーのように、システムの構造的レイヤーに深く埋め込まれる。AIなしでは成り立たない本質的なインテリジェンスが生まれる。
3.  **明確な人間/AIの境界設計**: 人間が方向性を提供し、AIが実行し、人間が検証する役割分担を明確にする。Karpathy氏が提唱する「部分的な自律性」では、完全な自律性より、AIの生成と人間の検証を高速で繰り返す「生成-検証ループ」の最適化が生産性向上に繋がると強調される。
4.  **認知的役割分担の最適化**: 人間の強み（目標設定、判断、創造性）とAIの強み（情報探索、パターン認識、実行）をマッピングし、互いの長所を活かすようタスクを配分する。

これらの原則は、AIを統合するプロダクトチームに具体的なフレームワークを提供する。筆者は、既存ワークフローの認知的作業を識別し、人間とAIの役割を再配分し、自律的な実行から逆算して設計する4ステップを提案。これはWebアプリの既存機能にAIを統合する上で非常に実践的な指針となる。

Karpathy氏がTeslaでの経験から語るように、AIが膨大な出力を生成しても、検証に時間がかかれば生産性は上がらない。真の生産性は、AIの自律性レベルではなく、「生成-検証ループ」の速度によって決まる。IFAの適用は、単なる「AI機能の追加」を超え、人間とAIの協調を根本から設計する「インテリジェントなシステム」構築を可能にし、より直感的で効率的なAI体験の開発に貢献する。

---

### AIに個性を与える：差別化を促す新しい人格パターン

https://uxdesign.cc/so-your-ai-wants-a-personality-9cbb47e07dd7

AI製品におけるユーザーエンゲージメント、信頼、差別化を促進するため、目的、世界観、価値観といった内部特性と、視覚、コミュニケーション、マルチモーダルフィードバックといった外部表現を組み合わせた、AI人格設計のフレームワークを提示する。




1966年のELIZA以来、人間は機械に感情や意図を投影する「ELIZA効果」を経験してきました。現代のAIシステムでは、この傾向がさらに重要性を増しており、AnthropicのClaudeのように、あらかじめ設計された価値観や倫理的推論がその応答を形成しています。著者は、AIの人格設計は単なるブランディングのレイヤーを超え、信頼、採用、長期的な習慣を形成する「核となるインタラクションレイヤー」へと変化していると指摘し、そのためのフレームワークを提示します。

このフレームワークは、AIの人格を、内部的な特性と、それらを可視化する外部的な表現の2層で構成すると説明しています。

**内部層：AIの根底にある特性**
1.  **目的、世界観、価値観**: AIがユーザーのために何を達成すべきか（目的）、問題にどうアプローチし推論するか（世界観）、そして守るべき倫理的境界線と優先事項（価値観）を定義します。Claudeのシステムプロンプトが、これらを明示的にプログラミングすることで、ユーザー体験を形成している例が挙げられています。
2.  **アーキタイプ**: カール・ユングの心理学に基づく普遍的なキャラクター原型（例：賢者、道化師）をAIに適用することで、視覚的表現やコミュニケーションスタイルに一貫性をもたせ、ユーザー体験を強化します。Claudeは「賢者」として思慮深くバランスの取れたアシスタントとして設計され、Wysaは「道化師＋コーチ」として共感的で遊び心のあるサポートを提供します。
3.  **バックストーリー**: MikoやCharacter.aiのように、AIに定義された役割や歴史を与えることで、感情的なつながりを深め、システムに生命感と意図性を付与します。
4.  **状況適応**: ユーザーの感情状態や文脈に応じて、トーン、言語、ペースを調整するAIの能力です。Alexaはニュースのポジティブさに応じて声のトーンを変え、Replikaは長期的な会話を通じてユーザーの語彙や感情パターンを学習し、自身の「人格」を形成します。

**外部層：内部特性を表現する表面的な要素**
1.  **視覚的アイデンティティ**: ロゴ、アバター、タイポグラフィ、色、ハードウェア形状などがAIの人格を視覚的に伝えます。PerplexityのミニマルなロゴやClaudeのセリフ体タイポグラフィは、それぞれAIの役割と個性を強化しています。
2.  **コミュニケーションスタイル**: トーン、フレーズ、ペース、フォーマルさといった要素が、音声やテキストを通じてAIのキャラクターを表現し、ユーザー体験を導きます。Capital OneのEnoが「First things first」を使うことで、より親しみやすい印象を与えている例が紹介されています。
3.  **マルチモーダルフィードバック**: AIの内部状態（リスニング、思考中、応答中など）を、視覚的キュー、音声、ハプティクス（触覚）などの複数の感覚チャネルを通じて表現する手法です。Replit AIはアイコンアニメーション、AlexaデバイスはLEDライトと音声トーン、Moxieロボットはスクリーンアニメーションや身体の動きを組み合わせ、人間らしい解釈可能なインタラクションを実現します。特に、人間とのタイミングを合わせるインタラクションのリズムとタイミングは、AIシステムが意図的で表情豊かに感じられるために重要です。

著者は、全てのAIシステムに個性が必要なわけではないと強調します。エンタープライズや高ユーティリティのアプリケーションでは精度、コンプライアンス、統合性が重視される一方、消費者向けAIでは、機能がコモディティ化する中で、個性こそがエンゲージメント、信頼、習慣形成を促進する差別化要因になると結論付けています。Webアプリケーションエンジニアは、AI製品の企画・開発において、このような人格設計のフレームワークを意識することで、ユーザーとの深い関係性を築き、製品の市場での成功に貢献できるでしょう。

---

### AI時代だからこそ、UXデザイナーが不可欠である理由

https://uxdaystokyo.com/articles/why-ux-designers-are-essential-for-ai/

データと具体的な失敗事例を分析し、AI時代においてUXデザイナーがAI製品のユーザー信頼、発見可能性、および実用的な成功を確保するために不可欠であると結論付けています。




AIの進化により「AIがあればUI/UX設計は不要」という説も囁かれる中、本記事はデータに基づき、むしろAI時代にこそUXデザイナーが不可欠であると強く主張します。Nielsen Norman Groupの2025年の研究では、「賢く見えるAI」は信頼されやすい一方で、「感情を持っているように見えるAI」は信頼を損なう可能性があり、特にメンタルヘルスのような高リスク領域では有害にもなりうると示されています。エンジニアが技術的にAIを人間らしく見せようとする傾向がある中、UXデザイナーはユーザー調査に基づき、AIの提示方法を設計する役割を担います。

過去の失敗事例がこの点を裏付けています。Amazon Alexa Skillsは、発見可能性の欠如やコンテキスト不足、ユーザビリティテストの不足により、技術的には動いてもユーザーに利用されませんでした。また、2024年に登場したHumane AI PinやRabbit r1といったAIファーストデバイスは、「技術的に可能」なことを「ユーザーが望む」と誤解した結果、ユースケースの不明確さ、バッテリー問題、サービス連携の不安定さ、応答速度の遅さといったUX課題が露呈し、市場で苦戦を強いられサービスが終息しました。これらは、UXデザイナーがユーザーリサーチを通して「本当に解決すべき課題」を特定し、初期段階でプロトタイプテストを行えば防げた可能性が高いと指摘されています。

Boston Consulting Groupの調査（2023年）は、AI導入におけるリーダー層と現場従業員の認識のギャップを明らかにし、このギャップが「技術の可能性」と「実際の使いやすさ」の差であることを示唆しています。UXデザイナーは、AIが持つ不確実性を前提とした「信頼の設計」（確信度表示、情報源明示）、ユーザーがAIの能力を理解し活用できる「発見可能性の設計」、そして予期せぬ挙動に対応する「エラー処理の設計」という3つの重要課題を解決します。

Forrester ResearchによればUXへの投資のROIは平均9,900%に達し、IBMの事例ではUX改善がコンバージョン率400%向上に繋がったと報告されています。AIプロダクトにおいても、UX設計済みのツールの採用率は65〜80%と高く、UI改善で問い合わせが40%減少し、早期テストで手戻りが70%削減されるなど、UXの経済的価値は明らかです。

結論として、エンジニアが「何ができるか」を作り、UXデザイナーは「何が使われるか」を設計するという役割分担が重要です。AIはデザインを生成する能力を持つかもしれませんが、Greg Nudelman氏の言葉の通り、「どんなAIを、どう人に使わせるか」を設計できるUXデザイナーこそが、AI時代の成功を左右する不可欠な存在であると本記事は強調しています。AI時代の成功は「技術的可能性 × ユーザー価値 × 倫理的配慮」によって決まり、UXデザイナーがこの方程式を完成させると締めくくられています。

---

### 「チャット＋AI」で崩壊するUIパターン

https://uxdaystokyo.com/articles/alternative-chat-ui-layout/

AIチャットにおけるエージェントの思考ログやツール呼び出しが従来のUIを機能不全に陥らせる問題に対し、プロセスと結果を分離する2ペインレイアウトが新たな解決策となると論じる。




Luke Wroblewski氏の解説を基に、AIチャット機能が普及する中で従来のUIパターンが直面している課題を指摘しています。AIが思考ログやツール呼び出し（エージェント的動作）を大量に挟むようになると、チャットはもはや人間同士の「会話」ではなく「内的独白（モノローグ）」のようになり、ユーザー体験を損ねると筆者は述べています。特にVS Codeのサイドパネルのような狭いUI空間では、AIの複雑なプロセスを追うことが難しく、ユーザーは文脈を見失いがちです。

デザインチームは、AIの思考ログをどこまで表示し、どこを折りたたむべきかというジレンマに直面します。すべてを隠せば不安を覚える一方、すべてを表示すれば情報過多になり、可読性が低下します。この問題を解決するため、記事では「チャット＋キャンバス」という概念、すなわち「プロセス（思考ログ、ツール呼び出し）」と「結果（生成物）」を異なる領域に配置するアプローチを提案。しかし、どこからが結果でどこまでが中間プロセスかの線引きが難しく、またプロセスと結果が離れすぎると文脈把握が困難になるという課題も指摘しています。

そこで、左右に2つのスクロール領域を持つ新しいレイアウトが提案されています。左列には「ユーザー指示、AIの思考ログ、ツール過程」を、右列には「AIの最終出力（結果）」を配置。AIの処理完了後には左側の思考ログが自動で要約に折りたたまれ、右側の結果はそのまま残ります。このレイアウトにより、ユーザーは結果をスムーズに追いながら、同時にその結果に至るプロセスを横目で参照できるという、革新的な体験が実現すると強調しています。

この2ペインレイアウトは、従来のチャットUIが抱えていた「指示、思考、ツール、出力」が混在し頻繁なスクロールを要する問題を解決し、AIエージェントが関与するアプリケーションのUI設計において、プロセスの透明性と結果の視認性を両立させる重要な解決策となり得ます。AIの進化に伴い、このような新しいUI課題は今後も増え続けると予測されており、開発者やデザイナーはAIと人が協働するためのUI設計の解像度を高める必要性が高まっています。

---

## 5. 最新モデルとツールのアップデート

### GPT-5.2の変更点とGPT-5.1からの違いを公式情報ベースでわかりやすく解説 #Python

https://qiita.com/ryosuke_ohori/items/edd387f7f863a3d04511

OpenAIのGPT-5.2は、単なる性能向上に留まらず、スプレッドシート作成やコード生成などの「成果物志向」に重点を置いて再設計されており、開発者はその特性を活かしたプロダクト改善のためにモデル構成やAPIの運用を最適化すべきだと解説します。




この記事は、OpenAIのGPT-5.2が単なる知能向上に留まらず、「成果物（artifact）志向」で再設計されたことを、公式情報を基に詳細に解説しています。特に、スプレッドシート作成、プレゼン構築、コード生成、長文理解、ツール利用といった知識労働の成果物を強化した点が重要であると筆者は強調しています。

ChatGPTの体験面では、GPT-5.2が「Instant」「Thinking」「Pro」の3階層を持ち、日常利用では「Auto」（自動切替）が中心となることがポイントです。各モデルは「賢い/速い」だけでなく、情報探索やコーディング、計画立案といった特定の作業に特化した役割が与えられ、特に形式が崩れると使い物にならないスライドや表計算などの「整ったアウトプット」で真価を発揮すると説明されています。

API面では、ChatGPTでの呼称とAPIモデル名（例: Instant → `gpt-5.2-chat-latest`）の対応が明示されています。GPT-5.2の追加要素として`xhigh`推論レベル、推論サマリ、新しい文脈管理である`compaction`が挙げられています。特に、`xhigh`は品質最優先タスクの最終段階でのみ利用し、`gpt-5.1`のデフォルト推論設定が`none`である点に注意が必要だと警告しています。また、`Pro`モデルはResponses API専用であり、長時間の処理は非同期・ジョブ化による運用（`background mode`）が前提とされています。

「成果物志向」を実務に落とし込むため、筆者は以下のタスク設計を提案しています。
*   **構造（schema）を持つ生成物**：表、仕様書、設計レビューなどには、`response_format`で`json_schema`を利用した構造化出力を仕込むことで再現性を高める。
*   **長時間・複数ステップ領域**：Responses APIの`previous_response_id`や`compaction`を活用し、状態を継承・圧縮して効率的に運用する。
*   **監査・説明責任領域**：推論の要約（summary）を利用し、エンタープライズ導入時の根拠説明に対応する。

ベンチマークの読み方については、数値だけでなく、難問でのやり切り度（能力差）、デバッグの手戻り減少による体感差、そして単価だけでなく到達品質までの試行回数が変わることでコストが変わる（コスト差）という視点を持つべきだと述べられています。

安全性に関しては、センシティブな会話（メンタルヘルス、自傷兆候など）での応答改善や、System Card Updateの公開により、安全性評価の一次情報が揃ったことがB2B導入において重要であるとしています。

PythonとFastAPIを用いた実装例では、Instant相当（`gpt-5.2-chat-latest`）で低レイテンシの問い合わせ、Thinking相当（`gpt-5.2`）で構造化されたAPI仕様骨子の生成、そしてPro相当（`gpt-5.2-pro`）を最終レビューの「ゲート」として非同期運用する三層アーキテクチャが提示されており、それぞれのモデルの強みを活かした実践的な活用法が具体的に示されています。これにより、モデル切替の設計は「全置換」ではなく、工程ごとにモデル階層を割り当てるのが現実的であるという筆者の主張が裏付けられています。

---

### GPT-5.2プロンプトガイド

https://cookbook.openai.com/examples/gpt-5/gpt-5-2_prompting_guide

OpenAIは、エンタープライズおよびエージェントワークロード向けに設計された最新フラッグシップモデル「GPT-5.2」の性能を最大限に引き出すためのプロンプト作成ガイドを公開しました。




OpenAIが公開した「GPT-5.2プロンプトガイド」は、エンタープライズおよびエージェントワークロード向けフラッグシップモデルGPT-5.2の性能を最大限に引き出すための実践的なプロンプト作成手法を提示しています。ウェブアプリケーションエンジニアにとって、本番環境で信頼性が高く、一貫した動作をするAIエージェントを構築する上で不可欠な指針となるでしょう。

GPT-5.2は、GPT-5や5.1と比較して、より厳密な指示順守、低い冗長性、洗練された計画構築能力が特徴です。特にコーディングやマルチツールエージェントシナリオで高い能力を発揮しますが、その性能を引き出すには明示的なプロンプトが鍵となります。

ガイドでは、以下の具体的なプロンプトパターンを推奨しています。
- **冗長性と出力形式の制御**: 意図しない詳細や過度な表現を避け、簡潔かつ構造化された回答を得るために、明確な長さ制限や出力形式（例：箇条書き、テーブル）を指定します。
- **スコープの逸脱防止**: 設計システムに厳密に沿うため、不必要な機能追加やスタイル変更を明示的に禁止し、開発範囲のブレを防ぎます。
- **長文コンテキスト管理**: 10kトークンを超える入力では、内部的な概要作成、制約の再提示、引用による根拠の明示を通じて、情報の見落としやリコール精度低下を防ぎます。
- **曖昧さとハルシネーションリスクの抑制**: 不明確なクエリには、モデルに明確化の質問を促すか、仮定を明確にした複数の解釈を提示させ、不確実な数値や参照の捏造を避ける自己チェックステップも推奨されます。

さらに、長期間のワークフローでコンテキストウィンドウの限界を超える場合、「コンパクション」機能（`/responses/compact`エンドポイント）を利用して過去の会話状態を効率的に圧縮し、推論の継続を可能にする手法が紹介されています。これにより、複雑なタスクを中断することなく処理できるようになります。

GPT-5.2への移行に際しては、まずモデルを切り替えた後、`reasoning_effort`パラメータを以前のモデルに合わせて設定し、評価スイートで性能を検証する段階的なアプローチが推奨されます。ウェブ検索や構造化データ抽出能力の向上についても言及され、研究基準の明確化やスキーマの提供が効果を高めるとしています。

このガイドは、GPT-5.2の強力な機能を活用し、より予測可能で高品質なAI駆動型ソリューションを開発するための実践的な知識をウェブアプリケーションエンジニアに提供します。

---

### CursorのV2.2やビジュアルエディタがリリースされたんじゃ（気になるアドベントカレンダーを添えて）

https://zenn.dev/genai/articles/cursor-update-v2_2

Cursorは、AIデバッグモード、ブラウザビジュアルエディタ、強化されたプランモード、およびAIコードレビューなどの最新アップデートにより、開発ワークフローの効率と品質を大幅に向上させます。




AI駆動開発ツールCursorが、V2.2およびV2.1のアップデートで開発ワークフローを革新する新機能を多数発表しました。これらのアップデートは、特にデバッグ、UI開発、計画、およびコードレビューのプロセスをAIの力で効率化し、開発者がより生産的に、より高品質なコードを生成できるように設計されています。

V2.2の目玉機能の一つは「Debug Mode」です。これはAIエージェントがコードベース全体を読み込み、バグの原因について複数の仮説を立て、コードにランタイムログ出力を埋め込んで問題を再現・修正する仕組みです。人間（開発者）との対話を通じて、何百行もの当てずっぽうな変更ではなく、ピンポイントな修正を提案し、スタックや言語を問わず厄介なバグの特定と修正を支援します。著者は、ログを配置する最適な場所や仮説の立て方、修正後の検証フローまで具体的に解説し、開発者がこの強力なデバッグ機能を最大限に活用できる理由を説明しています。

次に「Browser ビジュアルエディタ」は、エディタ内蔵ブラウザ機能にビジュアルエディタが統合されたことで、UI開発の体験を一変させます。ブラウザサイドバーのコンポーネントツリー上で要素をドラッグ＆ドロップしたり、CSSスタイルをリアルタイムで編集したりすることが可能です。編集内容は即座にコードに反映され、複数の要素を選択してテキストで指示するだけで、エージェントが対応するコード変更を自動実行します。これにより、デザインとコードの境界が曖昧になり、画面上の操作が直接コード修正につながる統一開発環境が実現され、特にフロントエンド開発の効率が劇的に向上すると著者は強調しています。

その他の重要なアップデートとして、Plan Modeが強化され、Mermaid記法によるインライン図表表示や、To-Do項目を新しいエージェントに割り当てて並列実行できる機能が追加されました。また、「Multi-agent judging」機能により、複数のエージェントが並列実行された際に、Cursorが自動で最適な解決策を選択し、その理由を提示することで、複数提案の比較検討の手間を省きます。「Pinned chats」は、重要なチャット履歴をピン留めしてコンテキストを維持できるため、長時間の対話でも情報を見失うことなく作業を進められるようになりました。

V2.1では「AI Code Reviews」が導入され、開発者がコードを編集すると、Cursorが変更点をリアルタイムで解析し、潜在的なバグや問題をサイドパネルに表示します。これにより、プルリクエストやCIツールを待つことなく、エディタ内で即座にバグ修正が可能になり、開発テンポが大幅に向上し、レビュアーの負担も軽減されると著者は述べています。

これらのアップデートは、AIを活用した開発環境が単なるコード生成を超え、デバッグ、デザイン、計画、レビューといった開発サイクルのあらゆる段階で、より深く、より実用的に統合されつつあることを示しており、webアプリケーションエンジニアの生産性とコード品質向上に直結する重要な進歩です。

---

### OpenAIが静かにスキルを導入、ChatGPTとCodex CLIで利用可能に

https://simonwillison.net/2025/Dec/12/openai-skills/

OpenAIがChatGPTとCodex CLIに「スキル」メカニズムを導入し、ファイルシステムベースのシンプルな設計でLLMの自動化能力を大幅に拡張している。




この記事は、OpenAIがChatGPTとCodex CLIに「スキル」メカニズムを静かに導入したことを報じています。これはAnthropicが以前発表したスキルと同様に、特定の機能やタスクを実行するための指示とリソース（Markdownファイルとオプションのスクリプト）をフォルダとして構造化するシンプルなファイルシステムベースの設計が特徴です。著者のSimon Willison氏は、この仕組みがLLMの能力を大きく拡張し、開発者のワークフローに重要な影響を与えると指摘しています。

ChatGPTのCode Interpreter機能では、新たに`/home/oai/skills`フォルダが追加され、ユーザーはプロンプトを通じてこれにアクセスできるようになりました。OpenAIは、スプレッドシート、docx、PDFなどのドキュメントを扱うためのスキルを提供しています。特にPDFや文書に対しては、レイアウトやグラフィック情報を保持するため、ページごとにPNGに変換し、ビジョン対応のGPTモデルに渡すという高度なアプローチを採用しており、テキスト抽出だけでは失われる情報を活用できると著者は説明しています。Willison氏はカカポの繁殖に関するPDF作成スキルを試用し、LLMがマクロン非対応フォントを自律的に修正するなど、その細部にわたる調整能力を高く評価しています。

さらに、OpenAIのオープンソースツールであるCodex CLIにも実験的なスキルサポートが追加されました。`~/.codex/skills`フォルダにスキルを配置し、`--enable skills`オプションで実行することで、特定のタスク（例えばDatasetteプラグインの作成）を自動化できます。著者は、Claude Opus 4.5でDatasetteプラグイン作成スキルを生成し、Codex CLIで実際に機能するPythonプラグインを生成することに成功し、その精度と実用性を実証しています。

Willison氏は、自身が以前から「スキル」のコンセプトを高く評価していたことが、OpenAIの今回の動きによって裏付けられたと感じています。このメカニズムのシンプルな仕様は、他のプラットフォームへの実装を容易にし、将来的にAgentic AI Foundationのような組織によって正式な標準として文書化されるべきだと提言しています。これは、ウェブアプリケーション開発者にとって、LLMがより高度な自動化、複雑なタスクの直接処理、そして柔軟なツール連携を可能にする重要な進展であり、より自律的なコーディングエージェントの進化を加速させるものとして注目されます。

---


## おわりに

今週の記事から浮かび上がるのは、AIツールが「どう使うか」から「何を作るべきか」を考えるフェーズへ移行しているという現実です。仕様書駆動開発、MCP統合、UX設計の重視——これらはすべて、AIを単なる「コーディング高速化ツール」として使う段階を超え、組織的な開発文化の一部として組み込む動きです。

そして、この変化の中で最も重要なのは、人間の役割が「コードを書く人」から「設計を考える人」へとシフトしていることです。AIが実装を担う時代において、私たちエンジニアの価値は「Why」と「What」を明確に定義できる能力にあります。来週も、この変革の最前線からの知見をお届けします。

---

*本レポートはClaude Code (Sonnet 4.5) を使用して編集されました。*
