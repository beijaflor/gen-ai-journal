## 自作コーディングエージェントのコンテキストエンジニアリング

https://zenn.dev/tkithrta/articles/6f7160584c3124

自作コーディングエージェント「Shaft」の開発者が、既存ツールの課題を解決するコンテキストエンジニアリングの具体的な手法と設計思想を詳細に解説します。

**Content Type**: ⚙️ Tools

**Scores**: Signal:4/5 | Depth:5/5 | Unique:5/5 | Practical:4/5 | Anti-Hype:5/5
**Main Journal**: 91/100 | **Annex Potential**: 93/100 | **Overall**: 92/100

**Topics**: [[AIコーディングエージェント, コンテキストエンジニアリング, プロンプトエンジニアリング, 構造化出力, 開発ツール]]

本記事は、自作コーディングエージェント「Shaft」の開発者が、既存のAIコーディングエージェント（Claude Code、Gemini CLIなど）が抱えるコンテキスト管理の根本的な問題を解決するための、具体的なコンテキストエンジニアリング手法を詳述しています。

著者は、従来のツールではどのコンテキストファイルが読み込まれているか不透明であり、コードリーディングやパケットキャプチャが必要となる現状を問題視。Shaftではこの課題に対し、「どのプロンプトが使用されているか明確に把握できる仕組み」として、システムプロンプトとユーザープロンプトをJSONとJinja2を組み合わせたテンプレートで完全に定義するアプローチを採用。これにより、ハードコーディングされたプロンプトが一切介在しない透明性の高い運用を実現しています。

特に強調されるのは、明示的なコンテキストファイル管理とパス処理の徹底です。Shaftは、対象ファイルや参照ファイルをオプションフラグやglobパターン、ファイルリストで手動指定できる機能を実装。これにより、LLMがファイル内容を推測する必要がなくなり、不必要なAPI呼び出しを削減し、コストと制御性を向上させています。また、絶対パスと相対パスの厳密な変換と検証を行うことで、LLMによるファイルパスの誤解釈を防ぎ、正確なファイル編集を保証します。

さらに、Structured Output機能により、JSON Schemaを用いてLLMからの出力形式を厳密に定義し、コード変更を正確に適用する仕組みを詳述。これにより、従来のツールで多用される「Available Tools」に頼ることなく、効率的かつ確実にコードを修正できる点を強調しています。

著者は、メモリ管理やRAG、Available Toolsといった一般的なエージェント機能については、現状のLLMの不確実性やコスト問題を理由に慎重な姿勢を示し、今後の実装にはユーザーが制御できる形での設計が不可欠であると指摘します。

このアプローチは、AIコーディングエージェントを自作することで、コンテキストエンジニアリングの深い理解と実践的なベストプラクティスが得られるという著者の持論を具体化したものであり、開発者にとって既存ツールの限界と効率的なエージェント設計のヒントを提供するものです。