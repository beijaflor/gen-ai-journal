## Context Engineering

https://blog.langchain.com/context-engineering-for-agents/

エージェントのコンテキストウィンドウを効率的に管理するための「コンテキストエンジニアリング」の概念を定義し、「書く、選択する、圧縮する、分離する」の4つの戦略と、LangGraphがそれらをいかにサポートするかを詳説する。

**Content Type**: ⚙️ Tools

**Scores**: Signal:5/5 | Depth:5/5 | Unique:4/5 | Practical:5/5 | Anti-Hype:4/5
**Main Journal**: 94/100 | **Annex Potential**: 90/100 | **Overall**: 92/100

**Topics**: [[AIエージェント, コンテキスト管理, LangGraph, LLM最適化, RAG]]

エージェント開発において、LLMのコンテキストウィンドウはCPUのRAMに相当し、その管理が性能、コスト、レイテンシーに直結します。タスクが長期化し、ツールからのフィードバックが蓄積すると、コンテキストウィンドウの限界超過やコスト増大、さらには「コンテキストポイズニング」といったエージェントのパフォーマンス低下問題が発生します。本記事は、この課題を解決する「コンテキストエンジニアリング」をエージェント開発者の最重要課題と位置づけ、そのための四つの主要戦略とLangGraphによる実装方法を詳述しています。

第一に「書く（Write）」戦略では、コンテキストをウィンドウ外に保存します。セッション内のノートとしての「スクラッチパッド」はファイルやランタイム状態オブジェクトで、セッションを跨ぐ「メモリ」はReflexionやGenerative Agentsのように自己生成されます。これらはLangGraphの短期・長期記憶機能でサポートされます。

第二に「選択する（Select）」戦略は、タスクに必要なコンテキストのみを取り込むことです。スクラッチパッドやメモリからの関連情報（例：few-shot、事実）の選択、RAGによる関連ツールやコードベース知識の取得が含まれます。LangGraphはノード単位での細粒度な状態選択、LangMemによるメモリ管理、Bigtoolライブラリによるツール選択を可能にします。

第三に「圧縮する（Compress）」戦略は、必要なトークンのみを保持することです。Claude Codeの「auto-compact」のように、対話履歴やトークン消費の多いツール出力を要約したり、古いメッセージをトリミングしたりします。LangGraphは低レベルのオーケストレーションにより、要約ノードの追加やツール出力の圧縮を柔軟に実装できます。

第四に「分離する（Isolate）」戦略は、コンテキストを分割して管理します。サブエージェントにコンテキストを分離する「マルチエージェント」や、サンドボックス環境でツール呼び出しの出力（例：画像）をLLMから独立させて管理する手法があります。LangGraphは状態オブジェクトによるコンテキスト分離、E2B/Pyodideサンドボックスとの連携、supervisor/swarmライブラリによるマルチエージェント構築をサポートします。

LangSmithはエージェントのトレーシングとトークン使用量追跡、性能評価に役立ち、LangGraphと組み合わせることで、コンテキストエンジニアリングの改善サイクルを効率的に回せる、と結んでいます。これは、リソース制約に直面するWebアプリケーションエンジニアにとって、LLMエージェントを実用レベルに引き上げるための具体的な手立てを示すものです。
