## Prompt Cachingを完全に理解してLLMコストを爆裂に下げる

https://zenn.dev/ubie_dev/articles/ade17afebabaa9

UbieのCTOが、LLMのコストとレイテンシを大幅に削減するPrompt Cachingの仕組み、効果的なコンテキスト設計プラクティス、主要LLMプロバイダごとの実装方法、およびコストシミュレーション手法を詳述します。

**Content Type**: Tutorial & Guide
**Language**: ja

**Scores**: Signal:5/5 | Depth:4/5 | Unique:3/5 | Practical:5/5 | Anti-Hype:5/5
**Main Journal**: 89/100 | **Annex Potential**: 84/100 | **Overall**: 88/100

**Topics**: [[Prompt Caching, LLMコスト最適化, プロンプト設計, マルチターン会話, LLM API連携]]

UbieのCTOが、LLMコスト最適化の鍵となるPrompt Caching（コンテキストキャッシング）について解説しています。これは、同一の入力プロンプトを繰り返す際にその部分をキャッシュし再利用することで、コストとレイテンシを大幅に削減する技術です。特にtoC向けLLMプロダクトを提供する上で重要であり、キャッシュヒット時には入力トークンコストを最大90%削減できる可能性があると指摘します。ただし、Prompt Cachingは入力トークンのみをキャッシュし、出力には影響しない点に注意が必要です。

効果的にキャッシュを効かせるためには、コンテキスト設計が重要です。記事では、固定システムプロンプトやマルチターン会話のように、変化しにくいプロンプトを先頭に配置する「前方一致」の原則を示します。具体的には、システムプロンプトを固定しユーザープロンプトが変化する場合や、会話履歴が積み重なるマルチターン会話において、以前の入力部分がキャッシュの対象となる例を挙げます。一方、システムプロンプトに現在時刻のような動的な値を埋め込むとキャッシュが機能しなくなるため、動的な入力はTool Useで取得させるべきだと提唱しています。これにより、履歴を破壊せずに動的な情報に対応しつつキャッシュを維持できると説明します。

主要なLLMプロバイダごとに実装方法とコストへの影響も詳述されています。OpenAIモデルはデフォルトで先頭一致する入力を自動でキャッシュし、1024トークンを超えるプロンプトで90%の入力コスト削減効果があります。Geminiも同様に自動キャッシュが有効ですが、明示的キャッシュも利用可能です。Claudeは自動キャッシュ機能がなく、`cache_control`オプションを用いて明示的にキャッシュを有効にする必要があります。Claudeの場合、キャッシュ書き込みには通常の1.25倍、読み込みには0.1倍のコストがかかるため、利用には注意が必要です。

さらに、記事では実際の会話ログデータを用いてPrompt Caching導入によるコスト削減効果を試算するためのSQLクエリも提供されており、エンジニアが自身のプロダクトで具体的な効果検証を行うための実践的な手段が示されています。著者は、まずは冒頭のシステムプロンプトだけでも試してみることを推奨し、その大きなコスト削減効果を強調しています。