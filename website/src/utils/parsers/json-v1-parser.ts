/**
 * JSON v1.0 Summary Parser
 *
 * Parses structured JSON summaries generated by Gemini with schema enforcement.
 */

import type { SummaryParser, SummaryFormat } from '../summary-parser';
import type { SummaryEntry } from '../content-parser';

interface JsonV1Metadata {
  version: string;
  generatedAt: string;
  generatedBy: string;
}

interface JsonV1Scores {
  signal: number;
  depth: number;
  uniqueness: number;
  practical: number;
  antiHype: number;
  mainJournal: number;
  annexPotential: number;
  overall: number;
}

interface JsonV1Content {
  title: string;
  originalTitle?: string | null;
  url: string;
  language: string;
  contentType: string;
  oneSentenceSummary: string;
  summaryBody: string;
  topics: string[];
  scores: JsonV1Scores;
}

interface JsonV1Summary {
  metadata: JsonV1Metadata;
  content: JsonV1Content;
}

export class JsonV1Parser implements SummaryParser {
  readonly format: SummaryFormat = 'json-v1';
  readonly version = '1.0';

  /**
   * Validate JSON structure against v1.0 schema
   */
  validate(content: string): boolean {
    try {
      const json = JSON.parse(content) as JsonV1Summary;

      // Check required top-level fields
      if (!json.metadata || !json.content) {
        console.error('Missing metadata or content fields');
        return false;
      }

      // Validate metadata
      if (json.metadata.version !== '1.0') {
        console.error(`Invalid version: ${json.metadata.version}`);
        return false;
      }

      if (!json.metadata.generatedAt || !json.metadata.generatedBy) {
        console.error('Missing generatedAt or generatedBy');
        return false;
      }

      // Validate content fields
      const required = [
        'title',
        'url',
        'language',
        'contentType',
        'oneSentenceSummary',
        'summaryBody',
        'topics',
        'scores'
      ];

      for (const field of required) {
        if (!(field in json.content)) {
          console.error(`Missing required field: ${field}`);
          return false;
        }
      }

      // Validate scores
      const scores = json.content.scores;
      const dimensionScores = [
        scores.signal,
        scores.depth,
        scores.uniqueness,
        scores.practical,
        scores.antiHype
      ];

      for (const score of dimensionScores) {
        if (score < 0 || score > 5) {
          console.error(`Dimension score out of range: ${score}`);
          return false;
        }
      }

      const compositeScores = [
        scores.mainJournal,
        scores.annexPotential,
        scores.overall
      ];

      for (const score of compositeScores) {
        if (score < 0 || score > 100) {
          console.error(`Composite score out of range: ${score}`);
          return false;
        }
      }

      // Validate topics array
      if (json.content.topics.length < 1 || json.content.topics.length > 5) {
        console.error(`Topics array must have 1-5 elements, got ${json.content.topics.length}`);
        return false;
      }

      return true;
    } catch (error) {
      console.error('JSON validation error:', error);
      return false;
    }
  }

  /**
   * Parse JSON summary and convert to unified SummaryEntry
   */
  parse(filePath: string, journalDate: string, content: string): SummaryEntry | null {
    try {
      const json = JSON.parse(content) as JsonV1Summary;

      // Extract ID and domain from filename (e.g., "001_example_com.json" -> "001", "example.com")
      const filename = filePath.split('/').pop() || '';
      const parsedFilename = this.parseSummaryFilename(filename);

      if (!parsedFilename) {
        console.error(`Failed to parse filename: ${filename}`);
        return null;
      }

      // Convert JSON content to markdown-compatible format
      const markdownBody = this.toMarkdownCompatible(json.content);

      // Calculate reading metrics
      const wordCount = this.countWords(markdownBody);
      const readingTime = this.calculateReadingTime(wordCount);
      const slug = this.generateSlug(json.content.title);
      // Use oneSentenceSummary directly for excerpt instead of extracting from markdown
      const excerpt = json.content.oneSentenceSummary;

      // Build SummaryEntry with JSON-specific metadata
      const entry: SummaryEntry = {
        id: parsedFilename.id,
        date: journalDate,
        filename,
        sourceUrl: json.content.url,
        domain: parsedFilename.domain,
        title: json.content.title,
        content: markdownBody,
        status: 'omitted', // Will be determined later by parent parser
        slug,
        wordCount,
        readingTime,
        excerpt,
        fullExcerpt: json.content.oneSentenceSummary, // Also set fullExcerpt to oneSentenceSummary

        // Standard optional fields
        language: json.content.language as 'ja' | 'en' | 'other',
        originalTitle: json.content.originalTitle || undefined,

        // JSON-specific metadata (extends base SummaryEntry)
        contentType: json.content.contentType,
        oneSentence: json.content.oneSentenceSummary,
        topics: json.content.topics,
        scores: json.content.scores,

        // Generation metadata
        metadata: {
          version: json.metadata.version,
          generatedAt: json.metadata.generatedAt,
          generatedBy: json.metadata.generatedBy,
          format: 'json'
        }
      };

      return entry;
    } catch (error) {
      console.error(`Failed to parse JSON summary ${filePath}:`, error);
      return null;
    }
  }

  /**
   * Parse filename to extract metadata (same logic as markdown parser)
   */
  private parseSummaryFilename(filename: string): {
    id: string;
    domain: string;
    path: string;
    url: string;
  } | null {
    try {
      // Remove .json extension
      const nameWithoutExt = filename.replace(/\.json$/, '');

      // Try format: 001_domain_com_path.json
      const formatMatch = nameWithoutExt.match(/^(\d{3})_(.+)$/);
      if (formatMatch) {
        const [, id, urlPart] = formatMatch;

        // Parse domain and path
        const parts = urlPart.split('_');
        if (parts.length < 1) {
          return null;
        }

        const domain = parts[0].replace(/_/g, '.');
        const path = parts.slice(1).join('/');

        // Reconstruct URL
        const url = `https://${domain}${path ? `/${path}` : ''}`;

        return { id, domain, path, url };
      }

      return null;
    } catch (error) {
      console.error(`Failed to parse summary filename ${filename}:`, error);
      return null;
    }
  }

  /**
   * Count words (Japanese + English)
   */
  private countWords(text: string): number {
    const japaneseChars = (text.match(/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g) || []).length;
    const englishWords = (text.match(/\b[A-Za-z]+\b/g) || []).length;
    return Math.round(japaneseChars * 0.5 + englishWords);
  }

  /**
   * Calculate reading time
   */
  private calculateReadingTime(wordCount: number): number {
    return Math.max(1, Math.ceil(wordCount / 200));
  }

  /**
   * Generate slug from title
   */
  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^\w\s\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .substring(0, 50)
      .trim();
  }


  /**
   * Convert JSON content to markdown-compatible string
   *
   * This allows existing MarkdownRenderer component to display JSON summaries
   * without modification. The summaryBody is already in markdown format.
   */
  private toMarkdownCompatible(content: JsonV1Content): string {
    // Unescape literal \\n sequences to actual newlines
    // This handles cases where JSON contains double-escaped newlines
    return content.summaryBody.replace(/\\n/g, '\n');
  }
}
