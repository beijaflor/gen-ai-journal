## AI設計壁打ちに使える、小さな合意を積み重ねるプロトコルを作った

https://zenn.dev/erukiti/articles/2512-micro-commit-protocol

AIエージェントとの設計プロセスで生じるユーザーの混乱を防ぎ、システムの全容を完全に理解しながら構築するために、最小単位で合意を積み重ねる「マイクロコミット合意プロトコル」を開発・公開しました。

**Content Type**: 📖 Tutorial & Guide
**Language**: ja

**Scores**: Signal:4/5 | Depth:4/5 | Unique:4/5 | Practical:5/5 | Anti-Hype:4/5
**Main Journal**: 88/100 | **Annex Potential**: 85/100 | **Overall**: 84/100

**Topics**: [[AIエージェント, プロンプトエンジニアリング, 開発ワークフロー, コード生成, LLM活用術]]

AIエージェント、特に高性能なLLMとの設計作業において、ユーザーが大量の情報に圧倒され、AIが参照資料を絶対視して勝手に設計を進めてしまうことで、混乱やコンテキストの無駄な消費が発生するという課題が指摘されています。この課題を解決するため、著者は「マイクロコミット合意プロトコル」を開発しました。

このプロトコルは、ユーザーがシステムの全容を「完全に理解しながら」構築できるよう、すべての実装プロセスを最小単位で可視化・直列化し、その時々の情報量を最小限に抑えることを目的としています。

プロトコルは以下の3つのルールで構成されています。
1.  **完全網羅と不可視化の禁止 (No Skipping)**: 複雑な論点だけでなく、「自明な実装」や「定数定義」などの単純作業も決してスキップせず、すべての工程を最小の構成要素に分解し、必ず一つずつ提示します。「その他はよしなにやっておきました」は厳禁とし、ファイルパスやDB名・カラム名を具体的に記述。既存コードと今回の意思決定が矛盾する場合は、意思決定を正として既存コードを破棄・置換することを重視します。
2.  **ナビゲーションと提示 (One by One)**: 依存関係の最も低い基礎から順に、AIが次のステップを選定し、提示します。各ステップでは、特定のフォーマット（「Step #n: 今回積み上げるパーツ」「合意対象内容」「解説」）のみを出力し、停止します。合意対象内容は3項目以内の具体的な仕様案とし、ユーザーの判断が必須な場合のみ選択肢や質問を記述します。
3.  **承認と進行 (Wait for Understanding)**: AIは提示後、必ず停止し、ユーザーの「OK」を待ってそのパーツの実装が完了したとみなし、即座に次のステップへ進みます。ユーザーが質問や修正を求めたら、それに応じ、合意した内容は設計書と意思決定ログに記載します。

著者は、このプロトコルをCodex with gpt-5.2で試したところ、やり取りの回数は増えるものの、大量の情報を投げ込まれて抜け漏れが発生したり、AIが謎の思い込みで作業したりすることを防ぎ、効率的な設計壁打ちが可能になったと述べています。これは「急がば回れ」のアプローチとして有効であるとしています。ただし、GeminiやClaudeなど他のLLMでの動作は未検証であり、微調整が必要な可能性を指摘。また、数十個のマイクロコミットの意思決定をまとめる難しさや、一回の合意項目を3つに絞るのが進捗を遅らせるため、5つにするか動的に調整するなどのさらなる工夫が必要であることも追記しています。