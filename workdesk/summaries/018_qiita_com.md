## 実運用での RAG 実装：精度を落とさず Cache Hit を向上させる Two-Phase Caching 戦略

https://qiita.com/tms-ducvu/items/f0640904fb3e8607fc2d

ユーザーの多様な表現を「意図」として正規化する2段階キャッシュ戦略を導入し、RAGの精度維持とコスト削減を強力に推進する。

**Content Type**: 🛠️ Technical Reference
**Language**: ja

**Scores**: Signal:4/5 | Depth:4/5 | Unique:4/5 | Practical:5/5 | Anti-Hype:4/5
**Main Journal**: 84/100 | **Annex Potential**: 84/100 | **Overall**: 84/100

**Topics**: [[RAG, Semantic Cache, LLM正規化, コスト削減, ソフトウェアアーキテクチャ]]

RAG（検索拡張生成）システムを本番環境で運用する際、多くのエンジニアが直面するのが「キャッシュのジレンマ」である。ベクトル類似度に基づくSemantic Cacheは、類似度の閾値を下げれば誤回答が増え、上げればヒット率が極端に低下するという課題を抱えている。著者はこの問題の本質を、キャッシュ判定が「文言の類似度」に単純に依存しすぎており、ユーザーが多様な表現で投げかける「意図（Intent）」を捉えきれていない点にあると分析している。

この解決策として提示されているのが「Two-Phase Caching（2段階キャッシュ）」というアーキテクチャ戦略である。この手法は、処理を2つのフェーズに分けることで、応答速度とヒット率のトレードオフを最適化する。まず「Phase 1 (Fast Path)」では、LLMを呼び出さずに生の質問文を用いてキャッシュを検索する。これにより、定型的な質問や直前の再質問に対して最小限のコストとレイテンシで応答を返却できる。

Phase 1でキャッシュが見つからなかった場合に実行される「Phase 2 (Slow Path)」がこの戦略の独自性である。ここでは軽量なLLMを用いて、表記揺れや言語特性、曖昧さを含むユーザーの入力を「正規化（Disambiguate）」し、システム内部で扱う標準的な「Canonical Query」へと変換する。例えば「バイクの価格」と「この車種の値段は？」といった異なる表現を同一の意図として集約してから、再度キャッシュを検索する。このアプローチにより、Embeddingモデルの精度だけに頼る手法よりも遥かに高いキャッシュヒット率を実現できる。

筆者は、この戦略を採用することでEmbeddingモデルのチューニング地獄から解放され、トラフィックが増加してもLLMコストを劇的に抑制できると主張する。また、正規化プロセスを介することで「元の質問」と「解釈された意図」のログを比較可能になり、デバッグや品質改善のサイクルを回しやすくなるメリットも強調している。実装面では、正規化プロンプトが勝手に情報を付加しないよう「創造させない」制約を設けることが肝要だという。RAGのコストパフォーマンス向上や、実運用における精度の安定化を目指す開発者にとって、非常に具体的かつ即効性のある知見となっている。