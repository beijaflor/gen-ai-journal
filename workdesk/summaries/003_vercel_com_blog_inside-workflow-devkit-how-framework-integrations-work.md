## Workflow DevKitの内部: フレームワーク統合の仕組み

https://vercel.com/blog/inside-workflow-devkit-how-framework-integrations-work

**Original Title**: Inside Workflow DevKit: How framework integrations work

Vercelは、Workflow DevKitが多様なフレームワークにまたがる耐久性のあるワークフローをどのように実現しているか、その核となる二段階統合パターンとSWCコンパイラプラグインによる変換メカニズムを詳細に解説する。

**Content Type**: Tools
**Language**: en

**Scores**: Signal:5/5 | Depth:4/5 | Unique:4/5 | Practical:4/5 | Anti-Hype:5/5
**Main Journal**: 86/100 | **Annex Potential**: 86/100 | **Overall**: 88/100

**Topics**: [[Workflow DevKit, フレームワーク統合, SWCコンパイラ, ビルドシステム, ホットモジュールリプレイスメント]]

Vercelは、開発者が任意のフレームワークとプラットフォームで耐久性のあるワークフローを構築できるよう設計されたWorkflow DevKit（WDK）の内部動作と、多様なフレームワーク統合を可能にする基盤パターンを明らかにしました。ローンチ当初はNext.jsとNitroをサポートしていましたが、現在ではSvelteKit、Astro、Express、Honoなど8つのフレームワークに対応しており、今後も拡充される予定です。

WDKの各フレームワーク統合は、本質的に「ビルド時」と「ランタイム時」という二段階パターンに従います。ビルド時フェーズでは、ワークフローとステップ関数が実行可能なハンドラファイルにコンパイルされ、バンドリング、出力ファイルの決定、フレームワーク固有の互換性パッチの適用、ホットモジュールリプレイスメント（HMR）の設定が行われます。ランタイム時フェーズでは、ワークフロークライアント変換が適用され、ビルド時に生成されたハンドラファイルがアプリケーションのサーバーからアクセス可能になり、手動でのエンドポイント設定なしにワークフローがHTTP経由で利用できるようになります。

この統合の核となるのはWDKのSWCコンパイラプラグインで、同じ入力ファイルをモードに応じて3つの異なる出力に変換します。
1.  **クライアントモード**: フレームワークのビルド時に実行され、ワークフロー呼び出しをHTTPクライアントコードに変換し、`workflowId`プロパティを追加します。
2.  **ステップモード**: WDKのesbuildフェーズで実行され、「use step」関数をステップロジックを実行するHTTPハンドラに変換します。
3.  **ワークフローモード**: 同様にesbuildフェーズで実行され、「use workflow」関数をサンドボックス化された仮想環境で実行されるオーケストレーターに変換します。
これにより、開発者は一度コードを書けば、コンパイラがクライアント、ステップハンドラ、ワークフローハンドラを自動的に生成します。

SvelteKitとの統合を例に挙げると、`workflowPlugin()`を`vite.config.ts`に追加するだけで統合が完了します。ビルド時にはViteとRollupを介したクライアント変換と、esbuildによるステップ・ワークフローハンドラの生成（`src/routes/.well-known/workflow/v1`内の`+server.js`ファイルとして）が並行して行われます。ランタイム時には、SvelteKitのファイルベースルーティングがこれらの生成されたファイルを自動的にHTTPエンドポイントとして公開します。異なるフレームワークの「リクエスト」オブジェクトの構造に対応するため、WDKは各生成ハンドラに小さな変換関数を注入し、Web Request APIとの互換性を確保しています。また、HMRもViteの`hotUpdate`フックを利用し、ワークフローファイルが変更された際にesbuildによる再ビルドをトリガーすることで、高速な開発サイクルを支援します。

Vercelは、フレームワークを「ファイルベースルーティングフレームワーク」（Next.js、SvelteKitなど）と「HTTPサーバーフレームワーク」（Express、Honoなど）の2つのカテゴリに分類しています。前者はフレームワークがハンドラファイルを自動的に発見してエンドポイントとして公開する一方、後者ではesbuildでワークフローをバンドルし、Nitroが仮想ハンドラとしてマウントすることでHTTPサーバーからワークフローエンドポイントに到達可能にします。

著者は、このフレームワーク非依存のアプローチが、既存のスタックに耐久性のあるワークフローを容易に追加できることの重要性を強調しています。特定のフレームワークへの移行を強制することなく、開発者が使い慣れた環境で耐久性のあるワークフローを利用できることは、採用の障壁を取り除き、WDKの目標である「耐久性をエコシステム全体にわたる言語レベルの概念にする」という目標に一歩近づいたと述べています。